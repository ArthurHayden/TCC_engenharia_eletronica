# -*- coding: utf-8 -*-
"""dataset_add_ruido.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yJEpMyRb8OWBOqHjsGKqreL-6WkOgJAc
"""

import numpy as np
import matplotlib.pyplot as plt
import os
from skimage import io, img_as_float
from skimage.util import random_noise
import random
from PIL import Image
from google.colab import drive

try:
    drive.mount('/content/gdrive')
except:
    pass
os.chdir('/content/gdrive/MyDrive/teste_acesso_colab_drive/dataset_ruido')
path = ('/content/gdrive/MyDrive/teste_acesso_colab_drive/dataset_ruido')

# Diretórios com as imagens originais
#AUTOR: ARTHUR CAMPELO (ArthurHayden )
teste_path = '/content/gdrive/MyDrive/teste_acesso_colab_drive/IA_MRI_4_classes/sartaj_dataset/Testing'

# Níveis de SNR desejados em dB
snr_db = [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
print("snr escolhidos ",snr_db)
chosen_class = random.choice(os.listdir(teste_path))
class_dir = os.path.join(teste_path, chosen_class)
image_files = os.listdir(class_dir)
chosen_image = random.choice(image_files)
image_path_2 = os.path.join(class_dir, chosen_image)

# Função para carregar uma imagem aleatória do diretório de treinamento
def random_image():
    chosen_class = random.choice(os.listdir(teste_path))
    class_dir = os.path.join(teste_path, chosen_class)
    image_files = os.listdir(class_dir)
    chosen_image = random.choice(image_files)
    image_path = os.path.join(class_dir, chosen_image)
    image = io.imread(image_path)
    return image

# Função para adicionar ruído gaussiano a uma imagem com um SNR específico
def add_noise(image, snr_db):
    snr_linear = 10 ** (snr_db / 10)
    #signal_power = np.mean(image ** 2)
    signal_power = np.mean(image.astype(np.float32) ** 2) / 255**2
    noise_variance = signal_power / snr_linear

    # Adicionar ruído gaussiano à imagem
    noisy_image = random_noise(image, mode='gaussian', var=noise_variance)
    return noisy_image

def add_noise_2(image, snr_db):
    image = image.astype(float)
    snr_linear = 10 ** (snr_db / 10)
    noise = np.random.normal(loc=0, scale=1.0, size=image.shape)
    snr=energy(image)/energy(noise)
    noise*=np.sqrt(snr/snr_linear)
    noisy_image = image + noise
    return noisy_image

def energy(x):
    y = x.astype(float)
    return np.sum(y**2)

def quantidade_imagens_por_classe(new_dir, dataset_type):
    print(f"\nQuantidade de imagens por classe no conjunto de '{dataset_type}':")
    for class_name in os.listdir(new_dir):
        class_dir = os.path.join(new_dir, class_name)
        num_images = len(os.listdir(class_dir))
        print(f"- {class_name}: {num_images} imagens")
# Exemplo de visualização de uma imagem com ruído (opcional)
image = random_image()
noisy_image = add_noise(image, 3)
image = Image.open(image_path_2)
print(image.mode)
plt.figure(figsize=(10, 5))
plt.imshow(noisy_image, cmap='gray')
plt.title('Imagem com Ruído')
plt.axis('off')
plt.show()
for i in range(10):
    image = random_image()
    #noisy_image = add_noise(image, snr_db[i])
    #utilizando a segunda função de adicionar ruido
    image_noisy = add_noise_2(image, snr_db[i])
    energy_image= energy(image)
    energy_noise= energy(image_noisy-image)
    snr_final=energy_image/energy_noise
    snr_sinal_db=10*np.log10(snr_final)
    fig, axes = plt.subplots(1, 2, figsize=(10, 5))
    axes[0].imshow(image, cmap='gray')
    axes[0].set_title('Imagem Original')
    axes[0].axis('off')

    axes[1].imshow(noisy_image, cmap='gray')
    axes[1].set_title(f'Imagem com Ruído (SNR = {snr_db[i]} dB)')
    axes[1].axis('off')
    plt.imshow(image_noisy/np.max(image_noisy))
    plt.show()

os.chdir('/content/gdrive/MyDrive/teste_acesso_colab_drive/dataset_ruido_2')
path_2 = ('/content/gdrive/MyDrive/teste_acesso_colab_drive/dataset_ruido_2')
# Criar os novos datasets com ruído
# Criar os novos datasets com ruído
for snr in snr_db:
    # Criar diretórios para treinamento e validação com o SNR específico
    new_teste_dir = os.path.join(path_2, f'teste_{snr}db')
    os.makedirs(new_teste_dir, exist_ok=True)  # Certifique-se de criar o diretório correto

    # Iterar sobre as classes e imagens nos diretórios originais
    class_names = os.listdir(teste_path)
    for class_name in class_names:
        original_teste_class_dir = os.path.join(teste_path, class_name)

        # Criar diretórios de classe nos novos datasets
        new_teste_class_dir = os.path.join(new_teste_dir, class_name)
        os.makedirs(new_teste_class_dir, exist_ok=True)

        # Processar as imagens de teste (corrigido)
        for filename in os.listdir(original_teste_class_dir):  # Iterar sobre as imagens no diretório original
            image_path = os.path.join(original_teste_class_dir, filename)
            image = io.imread(image_path)
            noisy_image = add_noise_2(image, snr)
            image_noisy_normalized = np.clip(noisy_image / np.max(noisy_image), 0, 1)
            #noisy_image = (noisy_image * 255).astype(np.uint8)
            #new_filename = f"{os.path.splitext(filename)[0]}_{snr}db.jpg"
            new_filename = f"{os.path.splitext(filename)[0]}_{snr}db_{class_name}.jpg"
            #io.imsave(os.path.join(new_teste_class_dir, new_filename), noisy_image)  # Salvar no diretório correto
            save_path = os.path.join(new_teste_class_dir, new_filename)
            plt.imsave(save_path, image_noisy_normalized)

    quantidade_imagens_por_classe(new_teste_dir, f'teste com SNR de {snr}dB')
    print(f"Datasets com SNR de {snr}dB criados com sucesso!")

original_image = io.imread(image_path_2)

# Criar uma figura para exibir todas as imagens juntas
fig, axes = plt.subplots(len(snr_db), 2, figsize=(10, 5 * len(snr_db)))

# Exibir a imagem original na primeira coluna
for i in range(len(snr_db)):
    axes[i, 0].imshow(original_image, cmap='gray')
    axes[i, 0].set_title('Imagem Original')
    axes[i, 0].axis('off')

# Gerar e exibir as imagens com ruído na segunda coluna
for i, snr in enumerate(snr_db):
    noisy_image = add_noise(original_image, snr)
    axes[i, 1].imshow(noisy_image, cmap='gray')
    axes[i, 1].set_title(f'Imagem com Ruído (SNR = {snr} dB)')
    axes[i, 1].axis('off')

# Ajustar o layout para evitar sobreposição de títulos
plt.tight_layout()

# Salvar a figura completa
plt.savefig('exemplo_imagens_com_ruido.png')
plt.show()

import os
import random
from PIL import Image
import matplotlib.pyplot as plt
from google.colab import drive

try:
    drive.mount('/content/gdrive')
except:
    pass

os.chdir('/content/gdrive/MyDrive/teste_acesso_colab_drive/dataset_ruido')
teste_path = '/content/gdrive/MyDrive/teste_acesso_colab_drive/IA_MRI_4_classes/sartaj_dataset/Testing'

# Lista para armazenar as imagens selecionadas e seus nomes de classe
imagens_selecionadas = []
nomes_classes = []

for classe in os.listdir(teste_path):
    classe_path = os.path.join(teste_path, classe)
    if os.path.isdir(classe_path):
        imagens_classe = [f for f in os.listdir(classe_path) if f.endswith('.jpg') or f.endswith('.png')]
        if imagens_classe:
            imagem_selecionada = random.choice(imagens_classe)
            imagem_path = os.path.join(classe_path, imagem_selecionada)
            imagens_selecionadas.append(Image.open(imagem_path))
            nomes_classes.append(classe) # Armazenar o nome da classe
            print(f"Classe: {classe}, Imagem: {imagem_selecionada}")
        else:
            print(f"Nenhuma imagem encontrada na classe: {classe}")

if not imagens_selecionadas:
    print("Nenhuma imagem foi selecionada. Verifique o caminho, a estrutura de diretórios e as permissões de acesso.")
else:
    fig, axes = plt.subplots(1, len(imagens_selecionadas), figsize=(12, 4))

    for i, imagem in enumerate(imagens_selecionadas):
        axes[i].imshow(imagem)
        axes[i].axis('off')
        axes[i].set_title(nomes_classes[i]) # Usar o nome da classe armazenado

    plt.tight_layout()
    fig.savefig('imagens_plotadas.png')
    plt.show()

    print("Imagem combinada salva com sucesso!")

def extract_metrics(filename):
    """Extrai as métricas de precisão, recall, f1_score e acurácia de um arquivo de texto."""
    with open(filename, 'r') as f:
        lines = f.readlines()

    metrics_line = next((line for line in lines if line.startswith('| Média |')), None)
    if metrics_line:
        values = metrics_line.split('|')
        precision = float(values[2].strip())
        recall = float(values[3].strip())
        f1_score = float(values[4].strip())
        accuracy = float(values[5].strip())
        return precision, recall, f1_score, accuracy
    else:
        return None, None, None, None

# Coletar as métricas de todos os arquivos
precision_values = []
recall_values = []
f1_score_values = []
accuracy_values = []

os.chdir('/content/gdrive/MyDrive/teste_acesso_colab_drive/dataset_ruido_2/rede_vgg16')
for snr in snr_db:
    filename = f'rede_vgg16_{snr}db.txt'  # Certifique-se de que o nome do arquivo está correto
    precision, recall, f1_score, accuracy = extract_metrics(filename)
    if precision is not None:
        precision_values.append(precision)
        recall_values.append(recall)
        f1_score_values.append(f1_score)
        accuracy_values.append(accuracy)

#precision_values[snr_db.index(3)] = 0.1901  # Média da precisão para 3 dB
#f1_score_values[snr_db.index(3)] = 0.2046   # Média do F1-score para 3 dB
#precision_values[snr_db.index(6)] = 0.2973  # Média da precisão para 6 dB
#f1_score_values[snr_db.index(6)] = 0.3092   # Média do F1-score para 6 dB
# Plotar os gráficos
plt.figure(figsize=(10, 6))

plt.plot(snr_db, precision_values, label='Precisão', marker='o')
plt.plot(snr_db, recall_values, label='Recall', marker='o')
plt.plot(snr_db, f1_score_values, label='F1-Score', marker='o')
plt.plot(snr_db, accuracy_values, label='Acurácia', marker='o')

# Definir os rótulos do eixo X (SNR)
plt.xticks(snr_db)

plt.xlim(3, 30)  # Começa em 3 dB e termina em 30 dB
plt.xlabel('SNR (dB)')
plt.ylabel('Valor da Métrica')
plt.legend()
plt.grid(True)
plt.savefig('grafico_snr_metricas_rede_vgg16.png')
plt.show()